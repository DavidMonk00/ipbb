#!/usr/bin/env python
from __future__ import print_function

from click_shell import shell
import click



#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
import os
#------------------------------------------------------------------------------
class DirSentry:
  def __init__(self, aDir):
    self.dir = aDir

  def __enter__(self):
    if not os.path.exists(self.dir):
        raise RuntimeError('stocazzo '+self.dir)

    self._lOldDir = os.path.realpath(os.getcwd())
    # print self._lOldDir
    os.chdir(self.dir)
    return self 

  def __exit__(self, type, value, traceback):
    import os
    os.chdir(self._lOldDir)
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
def trackFile(aAreaFileName):
  lPath = os.getcwd()

  # import pdb; pdb.set_trace()

  while lPath is not '/':
    lBuildFile = os.path.join(lPath,aAreaFileName)
    if os.path.exists(lBuildFile):
      return lBuildFile
    lPath,_ = os.path.split(lPath)

  return None
#------------------------------------------------------------------------------


#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Modules
import subprocess

# Elements
from os.path import join, split, exists, splitext

kBuildFileName = '.buildarea'
kWorkFileName = '.workarea'
kSourceDir = 'src'
enviroment = None

#------------------------------------------------------------------------------
class Environment(object):
    """docstring for Environment"""
    def __init__(self):
      super(Environment, self).__init__()

      self.root = None
      self.rootFile = None
      self.work = None
      self.workFile = None
      self.workConfig = None

      self._autodetect()

    def _autodetect(self):

        lBuildFilePath = trackFile(kBuildFileName)
        lWorkFilePath = trackFile(kWorkFileName)

        if lBuildFilePath:
          self.root, self.rootFile = os.path.split( lBuildFilePath )

        if lWorkFilePath:
          self.work, self.workFile = os.path.split( lWorkFilePath )
          import json
          with open(lWorkFilePath,'r') as lWorkFile:
            self.workConfig = json.load(lWorkFile)


    def __str__(self):
        return '{{ root: {root}, work: {work}, work_cfg: {workConfig} }}'.format(**(self.__dict__))

    @property
    def src(self):
      return join(self.root, kSourceDir) if self.root is not None else None

#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# @click.group()  # no longer
@shell(prompt='\x1b[38;5;74mipbb\x1b[0m> ', intro='Starting IPBus Builder...')
def cli():
  pass
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
@cli.command()
def env():
  '''Tentative command to set up shell environment'''
  print( 'export IPBB_ROOT=%s' % environment.root)
  print( 'export IPBB_WORK=%s' % environment.work)
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
@cli.command()
@click.argument('area')
@click.option('-r', '--repo')
def init(area, repo):
  '''Initialise a new firmware development area'''

  print('Setting up firmware area \''+area+'\'')


  if environment.root is not None:
    raise click.ClickException( 'Cannot create a new area inside an existing one %s' % environment.root )

  if exists(area):
      raise click.ClickException( 'Directory \'%s\' already exists' % area )

  # Build source code directory
  os.makedirs(join(area, kSourceDir))

  with open(join(area,kBuildFileName),'w') as lBuild:
      lBuild.write('\n')
  
  print('--->',repo,join(area, kSourceDir))
  if not repo:
      return
  else:
      with DirSentry( join(area, kSourceDir) ) as lSentry:
          subprocess.check_call(['git','clone',repo])

#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
@cli.group()
def add():
  pass
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
@add.command()
@click.argument( 'repo' )
@click.option( '-b', '--branch', default=None )
def git(repo, branch):
  '''Add a git repository to the source area'''
  
  # Must be in a build area
  if environment.root is None:
    raise click.ClickException('Build area root directory not found')

  print('adding git repository',repo)

  # Ensure that the destination direcotry doesn't exist
  # Maybe not necessary  
  from urlparse import urlparse
  
  lUrl = urlparse(repo)
  lRepoName = splitext(split(lUrl.path)[-1])[0]
  lRepoLocalPath = join(environment.root, kSourceDir, lRepoName)
  
  if exists(lRepoLocalPath):
    raise click.ClickException( 'Repository already exists \'%s\'' % lRepoLocalPath )

  lArgs = ['clone', repo]
  if branch is not None:
    lArgs += ['-b', branch]

  # Do the cloning
  with DirSentry( join(environment.root, kSourceDir) ) as lSentry:
    subprocess.check_call(['git']+lArgs)
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
@add.command()
@click.argument( 'repo' )
@click.option( '-n', '--dryrun', is_flag=True )
@click.option( '-s', '--sparse', default=None, multiple=True )
def svn(repo, dryrun, sparse):
  '''Add a svn repository/folder to the source area'''

  #------------------------------------------------------------------------------
  # Must be in a build area
  if environment.root is None:
    raise click.ClickException('Build area root directory not found')
  #------------------------------------------------------------------------------

  #------------------------------------------------------------------------------
  # Stop if the target directory already exists
  print('adding svn repository',repo)
  from urlparse import urlparse
  
  lUrl = urlparse(repo)
  lRepoName = splitext(split(lUrl.path)[-1])[0]
  lRepoLocalPath = join(environment.src, lRepoName)
  
  if exists(lRepoLocalPath):
    raise click.ClickException( 'Repository already exists \'%s\'' % lRepoLocalPath )
  #------------------------------------------------------------------------------

  #------------------------------------------------------------------------------
  if not sparse:
    lArgs = ['checkout', repo]
    # Do the checkout
    lCmd = ['svn']+lArgs
    print(' '.join(lCmd))
    with DirSentry( environment.src ) as lSrcSentry:
      if not dryrun:
        subprocess.check_call(lCmd)
  else:
    print (sparse)
    #------------------------------------------------------------------------------
    # Checkout an empty base folder
    lArgs = ['checkout', repo, '--depth=empty']
    lCmd = ['svn']+lArgs
    print(' '.join(lCmd))
    with DirSentry( environment.src ) as lSrcSentry:
      if not dryrun:
        subprocess.check_call(lCmd)
    #------------------------------------------------------------------------------
    lArgs = ['update']
    lCmd = ['svn']+lArgs
    with DirSentry( lRepoLocalPath ) as lSrcSentry:
      for lPath in sparse:
        lTokens = [ lToken for lToken in lPath.split('/') if lToken ]

        lPartials =  [ '/'.join(lTokens[:i+1]) for i,_ in enumerate(lTokens) ]

        for lPartial in lPartials:
            print (lCmd)
            lCmd = ['svn','up','--depth=empty',lPartial]
            subprocess.check_call(lCmd)

        lCmd = ['svn','up','--set-depth=infinity',lPath]
        print (lCmd)
        subprocess.check_call(lCmd)
        
  #------------------------------------------------------------------------------

#------------------------------------------------------------------------------

# #------------------------------------------------------------------------------
# @cli.group()
# def vivado():
#   pass
# #------------------------------------------------------------------------------


# #------------------------------------------------------------------------------
# def validateCmp(ctx, param, value):
#   lSeparators = value.count(':')
#   # Validate the format
#   if lSeparators > 1:
#     raise click.BadParameter('Malformed component name : %s. Expected <module>:<component>' % value)
  
#   return tuple(value.split(':'))


# @vivado.command()
# @click.argument('workarea')
# @click.argument('component', callback=validateCmp)
# @click.argument('dep')

# def create(workarea, component, dep):
#   #------------------------------------------------------------------------------
#   # Must be in a build area
#   if environment.root is None:
#     raise click.ClickException('Build area root directory not found')
#   #------------------------------------------------------------------------------

#   #------------------------------------------------------------------------------
#   lWorkAreaPath = join(environment.root, workarea)
#   if exists(lWorkAreaPath):
#     raise click.ClickException('Directory %s already exists' % lWorkAreaPath)
#   #------------------------------------------------------------------------------

#   #------------------------------------------------------------------------------
#   from dep2g.Pathmaker import Pathmaker
#   lPathmaker = Pathmaker(environment.src, 0)
#   lTopPackage, lTopComponent = component
#   # lTopDepPath = join(environment.src, lTopPackage, lTopComponent)
#   lTopDepPath = lPathmaker.getPath(lTopPackage, lTopComponent, 'include', dep)
#   if not exists(lTopDepPath):
#     raise click.ClickException('Top-level dependency file %s not found' % lTopDepPath)
#   #------------------------------------------------------------------------------

#   # Build source code directory
#   os.makedirs(lWorkAreaPath)

#   lCfg = {
#     'kind': 'vivado',
#     'topPkg': lTopPackage,
#     'topCmp': lTopComponent,
#     'topDep': dep,

#   }
#   with open(join(lWorkAreaPath,kWorkFileName),'w') as lWorkFile:
#     import json
#     json.dump(lCfg, lWorkFile, indent=2)
# #------------------------------------------------------------------------------


# #------------------------------------------------------------------------------
# @vivado.command()
# def project():

#   if environment.work is None:
#     raise click.ClickException('Work area root directory not found')

#   if environment.workConfig['kind'] != 'vivado':
#     raise click.ClickException('Work area type mismatch. Expected \'vivado\', found \'%s\'' % environment.workConfig['kind'] )


#   #------------------------------------------------------------------------------
#   # Very messy, to be sorted out later
#   from dep2g.Pathmaker import Pathmaker
#   from dep2g.DepFileParser import DepFileParser

#   class dummy:pass
#   lCommandLineArgs = dummy()
#   lCommandLineArgs.define = ''
#   lCommandLineArgs.product = 'vivado'
#   lCommandLineArgs.verbosity = 3
#   lCommandLineArgs.output = ''

#   lPathmaker = Pathmaker(environment.src, 0)

#   lCfg = environment.workConfig
#   lDepFileParser = DepFileParser( lCommandLineArgs , lPathmaker )
#   lDepFileParser.parse(lCfg['topPkg'], lCfg['topCmp'], lCfg['topDep'])

#   from dep2g.VivadoProjectMaker import VivadoProjectMaker
#   lWriter = VivadoProjectMaker(lCommandLineArgs, lPathmaker)

#   import xilinx.vivado
#   with xilinx.vivado.SmartConsole() as lTarget:
#     lWriter.write(lTarget,lDepFileParser.ScriptVariables, lDepFileParser.Components, lDepFileParser.CommandList, None, None)

#   #------------------------------------------------------------------------------
# #------------------------------------------------------------------------------

# #------------------------------------------------------------------------------
# @vivado.command()
# def build():
#   if environment.work is None:
#     raise click.ClickException('Work area root directory not found')

#   if environment.workConfig['kind'] != 'vivado':
#     raise click.ClickException('Work area type mismatch. Expected \'vivado\', found \'%s\'' % environment.workConfig['kind'] )

#   lOpenCmds = [
#     'open_project %s' % join(environment.work, 'top', 'top'),
#   ]

#   lSynthCmds = [
#     'launch_runs synth_1',
#     'wait_on_run synth_1',
#   ]

#   lImplCmds = [
#     'launch_runs impl_1',
#     'wait_on_run impl_1',
#   ]

#   lBitFileCmds = [
#     'launch_runs impl_1 -to_step write_bitstream',
#     'wait_on_run impl_1',
#   ]

#   import xilinx.vivado
#   with xilinx.vivado.SmartConsole() as lTarget:
#     lTarget(lOpenCmds)
#     lTarget(lSynthCmds)
#     lTarget(lImplCmds)
# #------------------------------------------------------------------------------

# #------------------------------------------------------------------------------
# @vivado.command()
# def bitfile():
#   if environment.work is None:
#     raise click.ClickException('Work area root directory not found')

#   if environment.workConfig['kind'] != 'vivado':
#     raise click.ClickException('Work area type mismatch. Expected \'vivado\', found \'%s\'' % environment.workConfig['kind'] )

#   lOpenCmds = [
#     'open_project %s' % join(environment.work, 'top', 'top'),
#   ]

#   lBitFileCmds = [
#     'launch_runs impl_1 -to_step write_bitstream',
#     'wait_on_run impl_1',
#   ]

#   import xilinx.vivado
#   with xilinx.vivado.SmartConsole() as lTarget:
#     lTarget(lOpenCmds)
#     lTarget(lBitFileCmds)
# #------------------------------------------------------------------------------

# #------------------------------------------------------------------------------
# @vivado.command()
# def reset():
#   if environment.work is None:
#     raise click.ClickException('Work area root directory not found')

#   if environment.workConfig['kind'] != 'vivado':
#     raise click.ClickException('Work area type mismatch. Expected \'vivado\', found \'%s\'' % environment.workConfig['kind'] )
  
#   lOpenCmds = [
#     'open_project %s' % join(environment.work, 'top', 'top'),
#   ]

#   lResetCmds = [
#     'reset_run synth_1',
#     'reset_run impl_1',
#   ]

#   import xilinx.vivado
#   with xilinx.vivado.SmartConsole() as lTarget:
#     lTarget(lOpenCmds)
#     lTarget(lResetCmds)
# #------------------------------------------------------------------------------

#------------------------------------------------------------------------------
if __name__ == '__main__':
  '''Discovers the environment at startup'''

  global environment
  environment = Environment()
  print(environment)

  # Add custom commands to shell
  import ipbb.vivado
  
  cli.add_command(ipbb.vivado.vivado)

  cli.shell.prompt = '\x1b[38;5;74m'+cli.shell.prompt+'\x1b[0m'
  cli()
#------------------------------------------------------------------------------
